// Generated by CoffeeScript 2.5.1
(function () {
  // Request Animation Frame Polyfill
  // CoffeeScript version of http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  var AnimatedText, AnimatedTextFactory, Bar, BaseDonut, BaseGauge, Donut, Gauge, GaugePointer, TextRenderer, ValueUpdater, addCommas, cutHex, formatNumber, mergeObjects, secondsToString,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf;

  (function () {
    var browserRequestAnimationFrame, isCancelled, j, lastId, len, vendor, vendors;
    vendors = ['ms', 'moz', 'webkit', 'o'];
    for (j = 0, len = vendors.length; j < len; j++) {
      vendor = vendors[j];
      if (window.requestAnimationFrame) {
        break;
      }
      window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
    }
    browserRequestAnimationFrame = null;
    lastId = 0;
    isCancelled = {};
    if (!requestAnimationFrame) {
      window.requestAnimationFrame = function (callback, element) {
        var currTime, id, lastTime, timeToCall;
        currTime = new Date().getTime();
        timeToCall = Math.max(0, 16 - (currTime - lastTime));
        id = window.setTimeout(function () {
          return callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
      // This implementation should only be used with the setTimeout()
      // version of window.requestAnimationFrame().
      return window.cancelAnimationFrame = function (id) {
        return clearTimeout(id);
      };
    } else if (!window.cancelAnimationFrame) {
      browserRequestAnimationFrame = window.requestAnimationFrame;
      window.requestAnimationFrame = function (callback, element) {
        var myId;
        myId = ++lastId;
        browserRequestAnimationFrame(function () {
          if (!isCancelled[myId]) {
            return callback();
          }
        }, element);
        return myId;
      };
      return window.cancelAnimationFrame = function (id) {
        return isCancelled[id] = true;
      };
    }
  })();

  secondsToString = function (sec) {
    var hr, min;
    hr = Math.floor(sec / 3600);
    min = Math.floor((sec - (hr * 3600)) / 60);
    sec -= (hr * 3600) + (min * 60);
    sec += '';
    min += '';
    while (min.length < 2) {
      min = '0' + min;
    }
    while (sec.length < 2) {
      sec = '0' + sec;
    }
    hr = hr ? hr + ':' : '';
    return hr + min + ':' + sec;
  };

  formatNumber = function (...num) {
    var digits, value;
    value = num[0];
    digits = 0 || num[1];
    return addCommas(value.toFixed(digits));
  };

  mergeObjects = function (obj1, obj2) {
    var key, out, val;
    out = {};
    for (key in obj1) {
      if (!hasProp.call(obj1, key)) continue;
      val = obj1[key];
      out[key] = val;
    }
    for (key in obj2) {
      if (!hasProp.call(obj2, key)) continue;
      val = obj2[key];
      out[key] = val;
    }
    return out;
  };

  addCommas = function (nStr) {
    var rgx, x, x1, x2;
    nStr += '';
    x = nStr.split('.');
    x1 = x[0];
    x2 = '';
    if (x.length > 1) {
      x2 = '.' + x[1];
    }
    rgx = /(\d+)(\d{3})/;
    while (rgx.test(x1)) {
      x1 = x1.replace(rgx, '$1' + ',' + '$2');
    }
    return x1 + x2;
  };

  cutHex = function (nStr) {
    if (nStr.charAt(0) === "#") {
      return nStr.substring(1, 7);
    }
    return nStr;
  };

  ValueUpdater = (function () {
    class ValueUpdater {
      constructor(addToAnimationQueue = true, clear = true) {
        this.clear = clear;
        if (addToAnimationQueue) {
          AnimationUpdater.add(this);
        }
      }

      update(force = false) {
        var diff;
        if (force || this.displayedValue !== this.value) {
          if (this.ctx && this.clear) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          }
          diff = this.value - this.displayedValue;
          if (Math.abs(diff / this.animationSpeed) <= 0.001) {
            this.displayedValue = this.value;
          } else {
            this.displayedValue = this.displayedValue + diff / this.animationSpeed;
          }
          this.render();
          return true;
        }
        return false;
      }

    };

    ValueUpdater.prototype.animationSpeed = 32;

    return ValueUpdater;

  }).call(this);

  BaseGauge = (function () {
    class BaseGauge extends ValueUpdater {
      setTextField(textField, fractionDigits) {
        return this.textField = textField instanceof TextRenderer ? textField : new TextRenderer(textField, fractionDigits);
      }

      setMinValue(minValue, updateStartValue = true) {
        var gauge, j, len, ref, results;
        this.minValue = minValue;
        if (updateStartValue) {
          this.displayedValue = this.minValue;
          ref = this.gp || [];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            gauge = ref[j];
            results.push(gauge.displayedValue = this.minValue);
          }
          return results;
        }
      }

      setOptions(options = null) {
        this.options = mergeObjects(this.options, options);
        if (this.textField) {
          this.textField.el.style.fontSize = options.fontSize + 'px';
        }
        if (this.options.angle > .5) {
          this.options.angle = .5;
        }
        this.configDisplayScale();
        return this;
      }

      configDisplayScale() {
        var backingStorePixelRatio, devicePixelRatio, height, prevDisplayScale, width;
        prevDisplayScale = this.displayScale;
        if (this.options.highDpiSupport === false) {
          delete this.displayScale;
        } else {
          devicePixelRatio = window.devicePixelRatio || 1;
          backingStorePixelRatio = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1;
          this.displayScale = devicePixelRatio / backingStorePixelRatio;
        }
        if (this.displayScale !== prevDisplayScale) {
          width = this.canvas.G__width || this.canvas.width;
          height = this.canvas.G__height || this.canvas.height;
          this.canvas.width = width * this.displayScale;
          this.canvas.height = height * this.displayScale;
          this.canvas.style.width = `${width}px`;
          this.canvas.style.height = `${height}px`;
          this.canvas.G__width = width;
          this.canvas.G__height = height;
        }
        return this;
      }

      parseValue(value) {
        value = parseFloat(value) || Number(value);
        if (isFinite(value)) {
          return value;
        } else {
          return 0;
        }
      }

    };

    BaseGauge.prototype.displayScale = 1;

    BaseGauge.prototype.forceUpdate = true;

    return BaseGauge;

  }).call(this);

  TextRenderer = class TextRenderer {
    constructor(el, fractionDigits1) {
      this.el = el;
      this.fractionDigits = fractionDigits1;
    }

    // Default behaviour, override to customize rendering
    render(gauge) {
      return this.el.innerHTML = formatNumber(gauge.displayedValue, this.fractionDigits);
    }

  };

  AnimatedText = (function () {
    class AnimatedText extends ValueUpdater {
      setVal(value) {
        return this.value = 1 * value;
      }

      constructor(elem1, text = false) {
        super();
        this.elem = elem1;
        this.text = text;
        if (this.elem === void 0) {
          throw new Error('The element isn\'t defined.');
        }
        this.value = 1 * this.elem.innerHTML;
        if (this.text) {
          this.value = 0;
        }
      }

      render() {
        var textVal;
        if (this.text) {
          textVal = secondsToString(this.displayedValue.toFixed(0));
        } else {
          textVal = addCommas(formatNumber(this.displayedValue));
        }
        return this.elem.innerHTML = textVal;
      }

    };

    AnimatedText.prototype.displayedValue = 0;

    AnimatedText.prototype.value = 0;

    return AnimatedText;

  }).call(this);

  AnimatedTextFactory = {
    create: function (objList) {
      var elem, j, len, out;
      out = [];
      for (j = 0, len = objList.length; j < len; j++) {
        elem = objList[j];
        out.push(new AnimatedText(elem));
      }
      return out;
    }
  };

  GaugePointer = (function () {
    class GaugePointer extends ValueUpdater {
      constructor(gauge1) {
        super(false, false);
        this.gauge = gauge1;
        if (this.gauge === void 0) {
          throw new Error('The element isn\'t defined.');
        }
        this.ctx = this.gauge.ctx;
        this.canvas = this.gauge.canvas;
        this.setOptions();
      }

      setOptions(options = null) {
        this.options = mergeObjects(this.options, options);
        this.length = 2 * this.gauge.radius * this.gauge.options.radiusScale * this.options.length;
        this.strokeWidth = this.canvas.height * this.options.strokeWidth;
        this.maxValue = this.gauge.maxValue;
        this.minValue = this.gauge.minValue;
        this.animationSpeed = this.gauge.animationSpeed;
        this.options.angle = this.gauge.options.angle;
        this.outlineWidth = this.canvas.height * this.options.outlineWidth;
        if (this.options.iconPath) {
          this.img = new Image();
          return this.img.src = this.options.iconPath;
        }
      }

      render() {
        var angle, endX, endY, imgX, imgY, startX, startY, x, y;
        angle = this.gauge.getAngle.call(this, this.displayedValue);
        x = Math.round(this.length * Math.cos(angle));
        y = Math.round(this.length * Math.sin(angle));
        startX = Math.round(this.strokeWidth * Math.cos(angle - Math.PI / 2));
        startY = Math.round(this.strokeWidth * Math.sin(angle - Math.PI / 2));
        endX = Math.round(this.strokeWidth * Math.cos(angle + Math.PI / 2));
        endY = Math.round(this.strokeWidth * Math.sin(angle + Math.PI / 2));
        this.ctx.beginPath();
        this.ctx.fillStyle = this.options.color;
        this.ctx.arc(0, 0, this.strokeWidth, 0, Math.PI * 2, false);
        this.ctx.fill();
        if (this.outlineWidth) {
          this.ctx.strokeStyle = this.options.outlineColor;
          this.ctx.lineWidth = this.options.outlineWidth;
          this.ctx.stroke();
        }
        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        this.ctx.lineTo(x, y);
        this.ctx.lineTo(endX, endY);
        this.ctx.fill();
        if (this.outlineWidth) {
          this.ctx.stroke();
        }
        if (this.img) {
          imgX = Math.round(this.img.width * this.options.iconScale);
          imgY = Math.round(this.img.height * this.options.iconScale);
          this.ctx.save();
          this.ctx.translate(x, y);
          this.ctx.rotate(angle + Math.PI / 180.0 * (90 + this.options.iconAngle));
          this.ctx.drawImage(this.img, -imgX / 2, -imgY / 2, imgX, imgY);
          return this.ctx.restore();
        }
      }

    };

    GaugePointer.prototype.displayedValue = 0;

    GaugePointer.prototype.value = 0;

    GaugePointer.prototype.options = {
      strokeWidth: 0.035,
      length: 0.1,
      color: "#000000",
      iconPath: null,
      iconScale: 1.0,
      iconAngle: 0,
      outlineColor: "#000000",
      outlineWidth: null
    };

    GaugePointer.prototype.img = null;

    return GaugePointer;

  }).call(this);

  Bar = class Bar {
    constructor(elem1) {
      this.elem = elem1;
    }

    updateValues(arrValues) {
      this.value = arrValues[0];
      this.maxValue = arrValues[1];
      this.avgValue = arrValues[2];
      return this.render();
    }

    render() {
      var avgPercent, valPercent;
      if (this.textField) {
        this.textField.text(formatNumber(this.value));
      }
      if (this.maxValue === 0) {
        this.maxValue = this.avgValue * 2;
      }
      valPercent = (this.value / this.maxValue) * 100;
      avgPercent = (this.avgValue / this.maxValue) * 100;
      $(".bar-value", this.elem).css({
        "width": valPercent + "%"
      });
      return $(".typical-value", this.elem).css({
        "width": avgPercent + "%"
      });
    }

  };

  Gauge = (function () {
    class Gauge extends BaseGauge {
      constructor(canvas) {
        var h, w;
        super();
        this.canvas = canvas;
        this.percentColors = null;
        if (typeof G_vmlCanvasManager !== 'undefined') {
          this.canvas = window.G_vmlCanvasManager.initElement(this.canvas);
        }
        this.ctx = this.canvas.getContext('2d');
        // Set canvas size to parent size
        h = this.canvas.clientHeight;
        w = this.canvas.clientWidth;
        this.canvas.height = h;
        this.canvas.width = w;
        this.gp = [new GaugePointer(this)];
        this.setOptions();
      }

      setOptions(options = null) {
        var gauge, j, len, phi, ref;
        super.setOptions(options);
        this.configPercentColors();
        this.extraPadding = 0;
        if (this.options.angle < 0) {
          phi = Math.PI * (1 + this.options.angle);
          this.extraPadding = Math.sin(phi);
        }
        this.availableHeight = this.canvas.height * (1 - this.paddingTop - this.paddingBottom);
        this.lineWidth = this.availableHeight * this.options.lineWidth; // .2 - .7
        this.radius = (this.availableHeight - this.lineWidth / 2) / (1.0 + this.extraPadding);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ref = this.gp;
        for (j = 0, len = ref.length; j < len; j++) {
          gauge = ref[j];
          gauge.setOptions(this.options.pointer);
          gauge.render();
        }
        this.render();
        return this;
      }

      configPercentColors() {
        var bval, gval, i, j, ref, results, rval;
        this.percentColors = null;
        if (this.options.percentColors !== void 0) {
          this.percentColors = new Array();
          results = [];
          for (i = j = 0, ref = this.options.percentColors.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
            rval = parseInt((cutHex(this.options.percentColors[i][1])).substring(0, 2), 16);
            gval = parseInt((cutHex(this.options.percentColors[i][1])).substring(2, 4), 16);
            bval = parseInt((cutHex(this.options.percentColors[i][1])).substring(4, 6), 16);
            results.push(this.percentColors[i] = {
              pct: this.options.percentColors[i][0],
              color: {
                r: rval,
                g: gval,
                b: bval
              }
            });
          }
          return results;
        }
      }

      set(value) {
        var gp, i, j, l, len, m, ref, ref1, val;
        if (!(value instanceof Array)) {
          value = [value];
        }
        // Ensure values are OK
        for (i = j = 0, ref = value.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          value[i] = this.parseValue(value[i]);
        }
        // check if we have enough GaugePointers initialized
        // lazy initialization
        if (value.length > this.gp.length) {
          for (i = l = 0, ref1 = value.length - this.gp.length; (0 <= ref1 ? l < ref1 : l > ref1); i = 0 <= ref1 ? ++l : --l) {
            gp = new GaugePointer(this);
            gp.setOptions(this.options.pointer);
            this.gp.push(gp);
          }
        } else if (value.length < this.gp.length) {
          // Delete redundant GaugePointers
          this.gp = this.gp.slice(this.gp.length - value.length);
        }
        // get max value and update pointer(s)
        i = 0;
        for (m = 0, len = value.length; m < len; m++) {
          val = value[m];
          // Limit pointer within min and max?
          if (val > this.maxValue) {
            if (this.options.limitMax) {
              val = this.maxValue;
            } else {
              this.maxValue = val + 1;
            }
          } else if (val < this.minValue) {
            if (this.options.limitMin) {
              val = this.minValue;
            } else {
              this.minValue = val - 1;
            }
          }
          this.gp[i].value = val;
          this.gp[i++].setOptions({
            minValue: this.minValue,
            maxValue: this.maxValue,
            angle: this.options.angle
          });
        }
        this.value = Math.max(Math.min(value[value.length - 1], this.maxValue), this.minValue); // TODO: Span maybe??

        // Force first .set()
        AnimationUpdater.add(this);
        AnimationUpdater.run(this.forceUpdate);
        return this.forceUpdate = false;
      }

      getAngle(value) {
        return (1 + this.options.angle) * Math.PI + ((value - this.minValue) / (this.maxValue - this.minValue)) * (1 - this.options.angle * 2) * Math.PI;
      }

      getColorForPercentage(pct, grad) {
        var color, endColor, i, j, rangePct, ref, startColor;
        if (pct === 0) {
          color = this.percentColors[0].color;
        } else {
          color = this.percentColors[this.percentColors.length - 1].color;
          for (i = j = 0, ref = this.percentColors.length - 1; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
            if (pct <= this.percentColors[i].pct) {
              if (grad === true) {
                // Gradually change between colors
                startColor = this.percentColors[i - 1] || this.percentColors[0];
                endColor = this.percentColors[i];
                rangePct = (pct - startColor.pct) / (endColor.pct - startColor.pct); // How far between both colors
                color = {
                  r: Math.floor(startColor.color.r * (1 - rangePct) + endColor.color.r * rangePct),
                  g: Math.floor(startColor.color.g * (1 - rangePct) + endColor.color.g * rangePct),
                  b: Math.floor(startColor.color.b * (1 - rangePct) + endColor.color.b * rangePct)
                };
              } else {
                color = this.percentColors[i].color;
              }
              break;
            }
          }
        }
        return 'rgb(' + [color.r, color.g, color.b].join(',') + ')';
      }

      getColorForValue(val, grad) {
        var pct;
        pct = (val - this.minValue) / (this.maxValue - this.minValue);
        return this.getColorForPercentage(pct, grad);
      }

      renderStaticLabels(staticLabels, w, h, radius) {
        var font, fontsize, j, len, match, re, ref, rest, rotationAngle, value;
        this.ctx.save();
        this.ctx.translate(w, h);
        // Scale font size the hard way - assuming size comes first.
        font = staticLabels.font || "10px Times";
        re = /\d+\.?\d?/;
        match = font.match(re)[0];
        rest = font.slice(match.length);
        fontsize = parseFloat(match) * this.displayScale;
        this.ctx.font = fontsize + rest;
        this.ctx.fillStyle = staticLabels.color || "#000000";
        this.ctx.textBaseline = "bottom";
        this.ctx.textAlign = "center";
        ref = staticLabels.labels;
        for (j = 0, len = ref.length; j < len; j++) {
          value = ref[j];
          if (value.label !== void 0) {
            // Draw labels depending on limitMin/Max
            if ((!this.options.limitMin || value >= this.minValue) && (!this.options.limitMax || value <= this.maxValue)) {
              font = value.font || staticLabels.font;
              match = font.match(re)[0];
              rest = font.slice(match.length);
              fontsize = parseFloat(match) * this.displayScale;
              this.ctx.font = fontsize + rest;
              rotationAngle = this.getAngle(value.label) - 3 * Math.PI / 2;
              this.ctx.rotate(rotationAngle);
              this.ctx.fillText(formatNumber(value.label, staticLabels.fractionDigits), 0, -radius - this.lineWidth / 2);
              this.ctx.rotate(-rotationAngle);
            }
          } else {
            // Draw labels depending on limitMin/Max
            if ((!this.options.limitMin || value >= this.minValue) && (!this.options.limitMax || value <= this.maxValue)) {
              rotationAngle = this.getAngle(value) - 3 * Math.PI / 2;
              this.ctx.rotate(rotationAngle);
              this.ctx.fillText(formatNumber(value, staticLabels.fractionDigits), 0, -radius - this.lineWidth / 2);
              this.ctx.rotate(-rotationAngle);
            }
          }
        }
        return this.ctx.restore();
      }

      renderTicks(ticksOptions, w, h, radius) {
        var currentDivision, currentSubDivision, divColor, divLength, divWidth, divisionCount, j, lineWidth, range, rangeDivisions, ref, results, scaleMutate, st, subColor, subDivisions, subLength, subWidth, subdivisionCount, t, tmpRadius;
        if (ticksOptions !== {}) {
          divisionCount = ticksOptions.divisions || 0;
          subdivisionCount = ticksOptions.subDivisions || 0;
          divColor = ticksOptions.divColor || '#fff';
          subColor = ticksOptions.subColor || '#fff';
          divLength = ticksOptions.divLength || 0.7; // default
          subLength = ticksOptions.subLength || 0.2; // default
          range = parseFloat(this.maxValue) - parseFloat(this.minValue); // total value range
          rangeDivisions = parseFloat(range) / parseFloat(ticksOptions.divisions); // get division step
          subDivisions = parseFloat(rangeDivisions) / parseFloat(ticksOptions.subDivisions);
          currentDivision = parseFloat(this.minValue);
          currentSubDivision = 0.0 + subDivisions;
          lineWidth = range / 400; // base
          divWidth = lineWidth * (ticksOptions.divWidth || 1);
          subWidth = lineWidth * (ticksOptions.subWidth || 1);
          results = [];
          for (t = j = 0, ref = divisionCount + 1; j < ref; t = j += 1) {
            this.ctx.lineWidth = this.lineWidth * divLength;
            scaleMutate = (this.lineWidth / 2) * (1 - divLength);
            tmpRadius = (this.radius * this.options.radiusScale) + scaleMutate;
            this.ctx.strokeStyle = divColor;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, tmpRadius, this.getAngle(currentDivision - divWidth), this.getAngle(currentDivision + divWidth), false);
            this.ctx.stroke();
            currentSubDivision = currentDivision + subDivisions;
            currentDivision += rangeDivisions;
            if (t !== ticksOptions.divisions && subdivisionCount > 0) { // if its not the last marker then draw subs
              results.push((function () {
                var l, ref1, results1;
                results1 = [];
                for (st = l = 0, ref1 = subdivisionCount - 1; l < ref1; st = l += 1) {
                  this.ctx.lineWidth = this.lineWidth * subLength;
                  scaleMutate = (this.lineWidth / 2) * (1 - subLength);
                  tmpRadius = (this.radius * this.options.radiusScale) + scaleMutate;
                  this.ctx.strokeStyle = subColor;
                  this.ctx.beginPath();
                  this.ctx.arc(0, 0, tmpRadius, this.getAngle(currentSubDivision - subWidth), this.getAngle(currentSubDivision + subWidth), false);
                  this.ctx.stroke();
                  results1.push(currentSubDivision += subDivisions);
                }
                return results1;
              }).call(this));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }

      //@ctx.restore()
      render() {
        var displayedAngle, fillStyle, gauge, h, j, l, len, len1, max, min, radius, ref, ref1, scaleMutate, tmpRadius, w, zone;
        // Draw using canvas
        w = this.canvas.width / 2;
        h = (this.canvas.height * this.paddingTop + this.availableHeight) - ((this.radius + this.lineWidth / 2) * this.extraPadding);
        displayedAngle = this.getAngle(this.displayedValue);
        if (this.textField) {
          this.textField.render(this);
        }
        this.ctx.lineCap = "butt";
        radius = this.radius * this.options.radiusScale;
        if (this.options.staticLabels) {
          this.renderStaticLabels(this.options.staticLabels, w, h, radius);
        }
        if (this.options.staticZones) {
          this.ctx.save();
          this.ctx.translate(w, h);
          this.ctx.lineWidth = this.lineWidth;
          ref = this.options.staticZones;
          for (j = 0, len = ref.length; j < len; j++) {
            zone = ref[j];
            // Draw zones depending on limitMin/Max
            min = zone.min;
            if (this.options.limitMin && min < this.minValue) {
              min = this.minValue;
            }
            max = zone.max;
            if (this.options.limitMax && max > this.maxValue) {
              max = this.maxValue;
            }
            tmpRadius = this.radius * this.options.radiusScale;
            if (zone.height) {
              this.ctx.lineWidth = this.lineWidth * zone.height;
              scaleMutate = (this.lineWidth / 2) * (zone.offset || 1 - zone.height);
              tmpRadius = (this.radius * this.options.radiusScale) + scaleMutate;
            }
            this.ctx.strokeStyle = zone.strokeStyle;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, tmpRadius, this.getAngle(min), this.getAngle(max), false);
            this.ctx.stroke();
          }
        } else {
          if (this.options.customFillStyle !== void 0) {
            fillStyle = this.options.customFillStyle(this);
          } else if (this.percentColors !== null) {
            fillStyle = this.getColorForValue(this.displayedValue, this.options.generateGradient);
          } else if (this.options.colorStop !== void 0) {
            if (this.options.gradientType === 0) {
              fillStyle = this.ctx.createRadialGradient(w, h, 9, w, h, 70);
            } else {
              fillStyle = this.ctx.createLinearGradient(0, 0, w, 0);
            }
            fillStyle.addColorStop(0, this.options.colorStart);
            fillStyle.addColorStop(1, this.options.colorStop);
          } else {
            fillStyle = this.options.colorStart;
          }
          this.ctx.strokeStyle = fillStyle;
          this.ctx.beginPath();
          this.ctx.arc(w, h, radius, (1 + this.options.angle) * Math.PI, displayedAngle, false);
          this.ctx.lineWidth = this.lineWidth;
          this.ctx.stroke();
          this.ctx.strokeStyle = this.options.strokeColor;
          this.ctx.beginPath();
          this.ctx.arc(w, h, radius, displayedAngle, (2 - this.options.angle) * Math.PI, false);
          this.ctx.stroke();
          this.ctx.save();
          this.ctx.translate(w, h);
        }
        if (this.options.renderTicks) {
          this.renderTicks(this.options.renderTicks, w, h, radius);
        }
        this.ctx.restore();
        // Draw pointers from (w, h)
        this.ctx.translate(w, h);
        ref1 = this.gp;
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          gauge = ref1[l];
          gauge.update(true);
        }
        return this.ctx.translate(-w, -h);
      }

    };

    Gauge.prototype.elem = null;

    Gauge.prototype.value = [20]; // we support multiple pointers

    Gauge.prototype.maxValue = 80;

    Gauge.prototype.minValue = 0;

    Gauge.prototype.displayedAngle = 0;

    Gauge.prototype.displayedValue = 0;

    Gauge.prototype.lineWidth = 40;

    Gauge.prototype.paddingTop = 0.1;

    Gauge.prototype.paddingBottom = 0.1;

    Gauge.prototype.percentColors = null;

    Gauge.prototype.options = {
      colorStart: "#6fadcf",
      colorStop: void 0,
      gradientType: 0, // 0 : radial, 1 : linear
      strokeColor: "#e0e0e0",
      pointer: {
        length: 0.8,
        strokeWidth: 0.035,
        iconScale: 1.0
      },
      angle: 0.15,
      lineWidth: 0.44,
      radiusScale: 1.0,
      fontSize: 40,
      limitMax: false,
      limitMin: false
    };

    return Gauge;

  }).call(this);

  BaseDonut = (function () {
    class BaseDonut extends BaseGauge {
      constructor(canvas) {
        super();
        this.canvas = canvas;
        if (typeof G_vmlCanvasManager !== 'undefined') {
          this.canvas = window.G_vmlCanvasManager.initElement(this.canvas);
        }
        this.ctx = this.canvas.getContext('2d');
        this.setOptions();
        this.render();
      }

      getAngle(value) {
        return (1 - this.options.angle) * Math.PI + ((value - this.minValue) / (this.maxValue - this.minValue)) * ((2 + this.options.angle) - (1 - this.options.angle)) * Math.PI;
      }

      setOptions(options = null) {
        super.setOptions(options);
        this.lineWidth = this.canvas.height * this.options.lineWidth;
        this.radius = this.options.radiusScale * (this.canvas.height / 2 - this.lineWidth / 2);
        return this;
      }

      set(value) {
        this.value = this.parseValue(value);
        if (this.value > this.maxValue) {
          if (this.options.limitMax) {
            this.value = this.maxValue;
          } else {
            this.maxValue = this.value;
          }
        } else if (this.value < this.minValue) {
          if (this.options.limitMin) {
            this.value = this.minValue;
          } else {
            this.minValue = this.value;
          }
        }
        AnimationUpdater.add(this);
        AnimationUpdater.run(this.forceUpdate);
        return this.forceUpdate = false;
      }

      render() {
        var displayedAngle, grdFill, h, start, stop, w;
        displayedAngle = this.getAngle(this.displayedValue);
        w = this.canvas.width / 2;
        h = this.canvas.height / 2;
        if (this.textField) {
          this.textField.render(this);
        }
        grdFill = this.ctx.createRadialGradient(w, h, 39, w, h, 70);
        grdFill.addColorStop(0, this.options.colorStart);
        grdFill.addColorStop(1, this.options.colorStop);
        start = this.radius - this.lineWidth / 2;
        stop = this.radius + this.lineWidth / 2;
        this.ctx.strokeStyle = this.options.strokeColor;
        this.ctx.beginPath();
        this.ctx.arc(w, h, this.radius, (1 - this.options.angle) * Math.PI, (2 + this.options.angle) * Math.PI, false);
        this.ctx.lineWidth = this.lineWidth;
        this.ctx.lineCap = "round";
        this.ctx.stroke();
        this.ctx.strokeStyle = grdFill;
        this.ctx.beginPath();
        this.ctx.arc(w, h, this.radius, (1 - this.options.angle) * Math.PI, displayedAngle, false);
        return this.ctx.stroke();
      }

    };

    BaseDonut.prototype.lineWidth = 15;

    BaseDonut.prototype.displayedValue = 0;

    BaseDonut.prototype.value = 33;

    BaseDonut.prototype.maxValue = 80;

    BaseDonut.prototype.minValue = 0;

    BaseDonut.prototype.options = {
      lineWidth: 0.10,
      colorStart: "#6f6ea0",
      colorStop: "#c0c0db",
      strokeColor: "#eeeeee",
      shadowColor: "#d5d5d5",
      angle: 0.35,
      radiusScale: 1.0
    };

    return BaseDonut;

  }).call(this);

  Donut = class Donut extends BaseDonut {
    strokeGradient(w, h, start, stop) {
      var grd;
      grd = this.ctx.createRadialGradient(w, h, start, w, h, stop);
      grd.addColorStop(0, this.options.shadowColor);
      grd.addColorStop(0.12, this.options._orgStrokeColor);
      grd.addColorStop(0.88, this.options._orgStrokeColor);
      grd.addColorStop(1, this.options.shadowColor);
      return grd;
    }

    setOptions(options = null) {
      var h, start, stop, w;
      super.setOptions(options);
      w = this.canvas.width / 2;
      h = this.canvas.height / 2;
      start = this.radius - this.lineWidth / 2;
      stop = this.radius + this.lineWidth / 2;
      this.options._orgStrokeColor = this.options.strokeColor;
      this.options.strokeColor = this.strokeGradient(w, h, start, stop);
      return this;
    }

  };

  window.AnimationUpdater = {
    elements: [],
    animId: null,
    addAll: function (list) {
      var elem, j, len, results;
      results = [];
      for (j = 0, len = list.length; j < len; j++) {
        elem = list[j];
        results.push(AnimationUpdater.elements.push(elem));
      }
      return results;
    },
    add: function (object) {
      if (indexOf.call(AnimationUpdater.elements, object) < 0) {
        return AnimationUpdater.elements.push(object);
      }
    },
    run: function (force = false) {
      var elem, finished, isCallback, j, k, l, len, ref, toRemove;
      // 'force' can take three values, for which these paths should be taken
      //   true: Force repaint of the gauges (typically on first Gauge.set)
      //   false: Schedule repaint (2nd or later call to Gauge.set)
      //   a number: It's a callback. Repaint and schedule new callback if not done.
      isCallback = isFinite(parseFloat(force));
      if (isCallback || force === true) {
        finished = true;
        toRemove = [];
        ref = AnimationUpdater.elements;
        for (k = j = 0, len = ref.length; j < len; k = ++j) {
          elem = ref[k];
          if (elem.update(force === true)) {
            finished = false;
          } else {
            toRemove.push(k);
          }
        }
        // Remove finished elements
        for (l = toRemove.length - 1; l >= 0; l += -1) {
          k = toRemove[l];
          AnimationUpdater.elements.splice(k, 1);
        }
        return AnimationUpdater.animId = finished ? null : requestAnimationFrame(AnimationUpdater.run);
      } else if (force === false) {
        if (AnimationUpdater.animId === !null) {
          // Cancel pending callback if animId is already set to avoid overflow
          cancelAnimationFrame(AnimationUpdater.animId);
        }
        return AnimationUpdater.animId = requestAnimationFrame(AnimationUpdater.run);
      }
    }
  };

  if (typeof window.define === 'function' && (window.define.amd != null)) {
    define(function () {
      return {
        Gauge: Gauge,
        Donut: Donut,
        BaseDonut: BaseDonut,
        TextRenderer: TextRenderer
      };
    });
  } else if (typeof module !== 'undefined' && (module.exports != null)) {
    module.exports = {
      Gauge: Gauge,
      Donut: Donut,
      BaseDonut: BaseDonut,
      TextRenderer: TextRenderer
    };
  } else {
    window.Gauge = Gauge;
    window.Donut = Donut;
    window.BaseDonut = BaseDonut;
    window.TextRenderer = TextRenderer;
  }

}).call(this);